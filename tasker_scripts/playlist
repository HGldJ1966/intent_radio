#!/bin/sh
# Version 0.1.1

# ########################################################################
# Constraints:
#    This script has to work with the standard Android shell, and with only
#    the utilities available on a vanilla Android installation (which
#    don't even include head and tail).
#
#    For URL encoding, we use sed if it's available.  Otherwise, we strip
#    out playlist entries which we know will not play (their file names
#    contain spaces).

root='/sdcard/Tasker/.intent_radio'
state="$root/state.txt"
seendir="$root/seen"
tmp="$state.tmp"
log="$root/log.txt"

# Bail early out early (to avoid even having to parse this script) if
# there's nothing to be done.
[ $# = 1 ] && ! [ -f $state ] && exit

mkdir -p "$root"
exec 4>> $log 2>&4
# set -x

log ()
{
   date +"%H:%M.%S $*" >&4
}

log "args $*"

ir_cleanup ()
{
   rm -fr "$state" "$seendir"
}

# ########################################################################
# Identify file types.

ir_is_url ()
{
   case "$1" in
      file://*  ) true ;;
      http://*  ) true ;;
      https://* ) true ;;
      content://* ) true ;;
      * ) false ;;
   esac
}

ir_is_playlist ()
{
   case "$1" in
      *.m3u  ) [ -f "$1" ] ;;
      * ) false ;;
   esac
}

ir_is_audio ()
{
   case "$1" in
      *.mp3  ) [ -f "$1" ] ;;
      *.aac  ) [ -f "$1" ] ;;
      *.m4a  ) [ -f "$1" ] ;;
      *.ogg  ) [ -f "$1" ] ;;
      *.oga  ) [ -f "$1" ] ;;
      *.flac ) [ -f "$1" ] ;;
      *.wav  ) [ -f "$1" ] ;;
      * ) false ;;
   esac
}

# ########################################################################
# URL encoding.

ir_urlencode_sed ()
{
   # Everything except: s/\//%2f/g;
   # Was sed 's/%/%25/g; s/ /%20/g; s/\t/%09/g; s/!/%21/g; s/"/%22/g; s/#/%23/g; s/\$/%24/g; s/\&/%26/g; s/(/%28/g; s/)/%29/g; s/\*/%2a/g; s/+/%2b/g; s/,/%2c/g; s/-/%2d/g; s/\./%2e/g; s/:/%3a/g; s/;/%3b/g; s//%3e/g; s/?/%3f/g; s/@/%40/g; s/\[/%5b/g; s/\\/%5c/g; s/\]/%5d/g; s/\^/%5e/g; s/_/%5f/g; s/`/%60/g; s/{/%7b/g; s/|/%7c/g; s/}/%7d/g; s/~/%7e/g; s/      /%09/g' | sed "s/'/%27/g"
   sed '/^\// {s/%/%25/g; s/ /%20/g; s/\t/%09/g;s/"/%22/g; s/#/%23/g; s/\&/%26/g; s/(/%28/g; s/)/%29/g; s/\*/%2a/g; s/+/%2b/g; s/,/%2c/g; s/:/%3a/g; s/;/%3b/g; s/>/%3e/g; s/?/%3f/g; s/@/%40/g; s/\[/%5b/g; s/\\/%5c/g; s/\]/%5d/g; s/\^/%5e/g; s/`/%60/g; s/{/%7b/g; s/|/%7c/g; s/}/%7d/g; s/~/%7e/g}' \
      | sed "/^\// {s/'/%27/g}"
}

ir_replace ()
{
   symbol="$1"
   replacement="$2"

   log "ir_replace symbol $symbol"

   while read line
   do
      log "ir_replace $symbol $line"
      done_first=''
      OLDIFS="$IFS"
      IFS="$symbol"
      for tok in $line
      do
         log "$tok"
         [ -n "$done_first" ] && echo -n "$replacement"
         echo -n "$tok"
         done_first='yes'
      done
      echo
      IFS="$OLDIFS"
   done
}

ir_urlencode_poor ()
{
   ir_replace "%" "%25" \
      | ir_replace " " "%20"
}

ir_url_encode ()
{
   if type sed > /dev/null
   then
      ir_urlencode_sed
   else
      # We know that the Android media player baulks at spaces...
      # grep -v ' '
      ir_urlencode_poor
   fi
}

ir_make_file_url ()
{
   while read f
   do
      case "$f" in
         /* ) echo "file://$f" ;;
         * ) echo "$f" ;;
      esac
   done
}

ir_urlencode_files ()
{
   ir_url_encode | ir_make_file_url
}

# ########################################################################
# Play.

ir_play ()
{
   if [ -n "$1" ]
   then
      log am broadcast -a 'org.smblott.intentradio.PLAY' -e url "$1" -e name "$1" # "${1##*/}"
      am broadcast -a 'org.smblott.intentradio.PLAY' -e url "$1" -e name "$1" # "${1##*/}"
   fi
}

ir_next ()
{
   while [ -f "$state" ] && [ -s "$state" ]
   do
      {
         read item
         cat >&3
      } < "$state" 3> "$tmp" && mv "$tmp" "$state"

      if ir_is_url "$item"
      then
         echo "$item"
         ir_play "$item"
         return
      fi
   done

   ir_cleanup
}

# ########################################################################
# Construct playlist for various types of thing.
#
# Each function assumes:
#  - The CWD is the location of the file or directory.
#  - It's first argument is the absolute path of the file or directory.

ir_playlist ()
{
   log "ir_playlist $(pwd) $1"
   log "  ls $(ls -l $1)"
   while read f
   do
      case "$f" in
         \#* ) true ;;
         /* ) [ -n "$f" ] && ir_process "/$f" ;;
         * ) [ -n "$f" ] && ir_process "$(pwd)/$f" ;;
      esac
   done < "$1"
}

ir_directory ()
{
   dir="$1"
   ls | while read file
      do
         ir_process "$dir/$file"
      done
}

ir_file ()
{
   echo "$1"
}

# ########################################################################
# Because playlist and directory handling is recursive, it is possible to
# get stuck in an infinite loop.  Here, we provide tests to ensure that
# cannot happen.

ir_see ()
{
   for thing
   do
      [ -d "$thing" ] && mkdir -p "$seendir/$thing"
      [ -f "$thing" ] && true > "$seendir/$thing"
   done
}

ir_seen ()
{
   [ -d "$seendir/$1" ] || [ -f "$seendir/$1" ]
}

# ########################################################################
# Keep the CWD as that of the thing we're currently handling.

ir_absolute_path ()
{
   if type readlink > /dev/null
   then
      # Amazingly, we have readlink in /system/bin (at least on my phone).
      readlink -f "$1"
   else
      # If we don't have readlink, then we'll try building an absolute path by hand.
      case "$1" in
         /* ) echo $1 ;;
         * ) echo "$(pwd)/$1"
      esac
   fi
}

# The first argument is either a directory or a file.
# cd to the directory or (in the case of a file) the containing directory.
# Then call the remaining command/arguments with the absolute path of the first
# argument appended.
# This allows us to handle both absolute and relative paths.
ir_cd ()
{
   thing=$(ir_absolute_path "$1")
   shift

   if [ -f "$thing" ]
   then
      directory="${thing%/*}"
   else
      directory="$thing"
   fi

   if ! ir_seen "$thing"
   then
      ir_see "$directory" "$thing"
      (
         if cd "$directory"
         then
            "$@" "$thing"
         fi
      )
   else
      log "skipping $thing"
   fi
}

# ########################################################################
# Handle various types of thing.

ir_process ()
{
   for arg
   do
      ir_is_url "$arg" && echo $arg
      [ -d "$arg" ] && ir_cd "$arg" ir_directory
      ir_is_playlist "$arg" && ir_cd "$arg" ir_playlist
      ir_is_audio "$arg" && ir_cd "$arg" ir_file
   done
}

# ########################################################################
# External operations.

ir_append ()
{
   log "append $*"
   ir_process "$*" | ir_urlencode_files >> "$state"

   log "state..."
   cat "$state" >&4
   log "...end"

   ir_next
}

ir_start ()
{
   ir_cleanup && ir_append "$@"
}

ir_stop ()
{
   [ -f "$state" ] && rm "$state"
}

case "$1" in
   'start'    ) shift; ir_start "$@" ;;
   'append'   ) shift; ir_append "$@" ;;
   'next'     ) ir_next ;;
   'complete' ) ir_next ;;
   'stop'     ) ir_stop ;;
esac

true
